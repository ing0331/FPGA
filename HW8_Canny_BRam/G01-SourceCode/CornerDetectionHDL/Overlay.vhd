-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\CornerDetectionHDL\Overlay.vhd
-- Created: 2023-06-21 14:30:32
-- 
-- Generated by MATLAB 9.14 and HDL Coder 4.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Overlay
-- Source Path: CornerDetectionHDL/HDL Corner Algorithm/Overlay
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.HDL_Corner_Algorithm_pkg.ALL;

ENTITY Overlay IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        RGBIn                             :   IN    vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
        BinaryIn                          :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        OverlayRGB                        :   IN    vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
        OverlayTransp                     :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        CtrlIn_hStart                     :   IN    std_logic;
        CtrlIn_hEnd                       :   IN    std_logic;
        CtrlIn_vStart                     :   IN    std_logic;
        CtrlIn_vEnd                       :   IN    std_logic;
        CtrlIn_valid                      :   IN    std_logic;
        RGBout                            :   OUT   vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
        CtrlOut_hStart                    :   OUT   std_logic;
        CtrlOut_hEnd                      :   OUT   std_logic;
        CtrlOut_vStart                    :   OUT   std_logic;
        CtrlOut_vEnd                      :   OUT   std_logic;
        CtrlOut_valid                     :   OUT   std_logic
        );
END Overlay;


ARCHITECTURE rtl OF Overlay IS

  -- Signals
  SIGNAL RGBIn_unsigned                   : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Data_Type_Conversion_out1        : vector_of_unsigned8(0 TO 2);  -- ufix8_En8 [3]
  SIGNAL Delay11_out1                     : vector_of_unsigned8(0 TO 2);  -- ufix8_En8 [3]
  SIGNAL Constant_out1                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL BinaryIn_unsigned                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Constant1_out1                   : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL OverlayTransp_unsigned           : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Switch_out1                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Add3_out1                        : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Data_Type_Conversion1_out1       : unsigned(7 DOWNTO 0);  -- ufix8_En8
  SIGNAL Delay12_out1                     : unsigned(7 DOWNTO 0);  -- ufix8_En8
  SIGNAL Product_mul_temp                 : vector_of_unsigned16(0 TO 2);  -- ufix16_En16 [3]
  SIGNAL Product_out1                     : vector_of_unsigned8(0 TO 2);  -- ufix8_En8 [3]
  SIGNAL Delay9_out1                      : vector_of_unsigned8(0 TO 2);  -- ufix8_En8 [3]
  SIGNAL OverlayRGB_unsigned              : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Data_Type_Conversion5_out1       : vector_of_unsigned8(0 TO 2);  -- ufix8_En8 [3]
  SIGNAL Delay13_out1                     : vector_of_unsigned8(0 TO 2);  -- ufix8_En8 [3]
  SIGNAL Data_Type_Conversion2_out1       : unsigned(7 DOWNTO 0);  -- ufix8_En8
  SIGNAL Delay14_out1                     : unsigned(7 DOWNTO 0);  -- ufix8_En8
  SIGNAL Product1_mul_temp                : vector_of_unsigned16(0 TO 2);  -- ufix16_En16 [3]
  SIGNAL Product1_out1                    : vector_of_unsigned8(0 TO 2);  -- ufix8_En8 [3]
  SIGNAL Delay8_out1                      : vector_of_unsigned8(0 TO 2);  -- ufix8_En8 [3]
  SIGNAL Add_out1                         : vector_of_unsigned8(0 TO 2);  -- ufix8_En8 [3]
  SIGNAL Delay2_out1                      : vector_of_unsigned8(0 TO 2);  -- ufix8_En8 [3]
  SIGNAL Data_Type_Conversion8_out1       : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Delay23_out1_hStart              : std_logic;
  SIGNAL Delay10_out1_hStart              : std_logic;
  SIGNAL Delay3_out1_hStart               : std_logic;
  SIGNAL Delay23_out1_hEnd                : std_logic;
  SIGNAL Delay10_out1_hEnd                : std_logic;
  SIGNAL Delay3_out1_hEnd                 : std_logic;
  SIGNAL Delay23_out1_vStart              : std_logic;
  SIGNAL Delay10_out1_vStart              : std_logic;
  SIGNAL Delay3_out1_vStart               : std_logic;
  SIGNAL Delay23_out1_vEnd                : std_logic;
  SIGNAL Delay10_out1_vEnd                : std_logic;
  SIGNAL Delay3_out1_vEnd                 : std_logic;
  SIGNAL Delay23_out1_valid               : std_logic;
  SIGNAL Delay10_out1_valid               : std_logic;
  SIGNAL Delay3_out1_valid                : std_logic;

BEGIN
  outputgen2: FOR k IN 0 TO 2 GENERATE
    RGBIn_unsigned(k) <= unsigned(RGBIn(k));
  END GENERATE;

  Data_Type_Conversion_out1 <= RGBIn_unsigned;

  Delay11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay11_out1 <= (OTHERS => to_unsigned(16#00#, 8));
      ELSIF enb = '1' THEN
        Delay11_out1 <= Data_Type_Conversion_out1;
      END IF;
    END IF;
  END PROCESS Delay11_process;


  Constant_out1 <= to_unsigned(16#FF#, 8);

  BinaryIn_unsigned <= unsigned(BinaryIn);

  Constant1_out1 <= to_unsigned(16#00#, 8);

  OverlayTransp_unsigned <= unsigned(OverlayTransp);

  
  Switch_out1 <= Constant1_out1 WHEN BinaryIn_unsigned = to_unsigned(16#00#, 8) ELSE
      OverlayTransp_unsigned;

  Add3_out1 <= Constant_out1 - Switch_out1;

  Data_Type_Conversion1_out1 <= Add3_out1;

  Delay12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay12_out1 <= to_unsigned(16#00#, 8);
      ELSIF enb = '1' THEN
        Delay12_out1 <= Data_Type_Conversion1_out1;
      END IF;
    END IF;
  END PROCESS Delay12_process;



  Product_out1_gen: FOR t_0 IN 0 TO 2 GENERATE
    Product_mul_temp(t_0) <= Delay11_out1(t_0) * Delay12_out1;
    Product_out1(t_0) <= Product_mul_temp(t_0)(15 DOWNTO 8);
  END GENERATE Product_out1_gen;


  Delay9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay9_out1 <= (OTHERS => to_unsigned(16#00#, 8));
      ELSIF enb = '1' THEN
        Delay9_out1 <= Product_out1;
      END IF;
    END IF;
  END PROCESS Delay9_process;


  outputgen1: FOR k IN 0 TO 2 GENERATE
    OverlayRGB_unsigned(k) <= unsigned(OverlayRGB(k));
  END GENERATE;

  Data_Type_Conversion5_out1 <= OverlayRGB_unsigned;

  Delay13_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay13_out1 <= (OTHERS => to_unsigned(16#00#, 8));
      ELSIF enb = '1' THEN
        Delay13_out1 <= Data_Type_Conversion5_out1;
      END IF;
    END IF;
  END PROCESS Delay13_process;


  Data_Type_Conversion2_out1 <= Switch_out1;

  Delay14_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay14_out1 <= to_unsigned(16#00#, 8);
      ELSIF enb = '1' THEN
        Delay14_out1 <= Data_Type_Conversion2_out1;
      END IF;
    END IF;
  END PROCESS Delay14_process;



  Product1_out1_gen: FOR t_01 IN 0 TO 2 GENERATE
    Product1_mul_temp(t_01) <= Delay13_out1(t_01) * Delay14_out1;
    Product1_out1(t_01) <= Product1_mul_temp(t_01)(15 DOWNTO 8);
  END GENERATE Product1_out1_gen;


  Delay8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay8_out1 <= (OTHERS => to_unsigned(16#00#, 8));
      ELSIF enb = '1' THEN
        Delay8_out1 <= Product1_out1;
      END IF;
    END IF;
  END PROCESS Delay8_process;



  Add_out1_gen: FOR t_02 IN 0 TO 2 GENERATE
    Add_out1(t_02) <= Delay9_out1(t_02) + Delay8_out1(t_02);
  END GENERATE Add_out1_gen;


  Delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay2_out1 <= (OTHERS => to_unsigned(16#00#, 8));
      ELSIF enb = '1' THEN
        Delay2_out1 <= Add_out1;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  Data_Type_Conversion8_out1 <= Delay2_out1;

  outputgen: FOR k IN 0 TO 2 GENERATE
    RGBout(k) <= std_logic_vector(Data_Type_Conversion8_out1(k));
  END GENERATE;

  c_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay23_out1_hStart <= '0';
      ELSIF enb = '1' THEN
        Delay23_out1_hStart <= CtrlIn_hStart;
      END IF;
    END IF;
  END PROCESS c_process;


  c_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_out1_hStart <= '0';
      ELSIF enb = '1' THEN
        Delay10_out1_hStart <= Delay23_out1_hStart;
      END IF;
    END IF;
  END PROCESS c_1_process;


  c_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_out1_hStart <= '0';
      ELSIF enb = '1' THEN
        Delay3_out1_hStart <= Delay10_out1_hStart;
      END IF;
    END IF;
  END PROCESS c_2_process;


  c_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay23_out1_hEnd <= '0';
      ELSIF enb = '1' THEN
        Delay23_out1_hEnd <= CtrlIn_hEnd;
      END IF;
    END IF;
  END PROCESS c_3_process;


  c_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_out1_hEnd <= '0';
      ELSIF enb = '1' THEN
        Delay10_out1_hEnd <= Delay23_out1_hEnd;
      END IF;
    END IF;
  END PROCESS c_4_process;


  c_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_out1_hEnd <= '0';
      ELSIF enb = '1' THEN
        Delay3_out1_hEnd <= Delay10_out1_hEnd;
      END IF;
    END IF;
  END PROCESS c_5_process;


  c_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay23_out1_vStart <= '0';
      ELSIF enb = '1' THEN
        Delay23_out1_vStart <= CtrlIn_vStart;
      END IF;
    END IF;
  END PROCESS c_6_process;


  c_7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_out1_vStart <= '0';
      ELSIF enb = '1' THEN
        Delay10_out1_vStart <= Delay23_out1_vStart;
      END IF;
    END IF;
  END PROCESS c_7_process;


  c_8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_out1_vStart <= '0';
      ELSIF enb = '1' THEN
        Delay3_out1_vStart <= Delay10_out1_vStart;
      END IF;
    END IF;
  END PROCESS c_8_process;


  c_9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay23_out1_vEnd <= '0';
      ELSIF enb = '1' THEN
        Delay23_out1_vEnd <= CtrlIn_vEnd;
      END IF;
    END IF;
  END PROCESS c_9_process;


  c_10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_out1_vEnd <= '0';
      ELSIF enb = '1' THEN
        Delay10_out1_vEnd <= Delay23_out1_vEnd;
      END IF;
    END IF;
  END PROCESS c_10_process;


  c_11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_out1_vEnd <= '0';
      ELSIF enb = '1' THEN
        Delay3_out1_vEnd <= Delay10_out1_vEnd;
      END IF;
    END IF;
  END PROCESS c_11_process;


  c_12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay23_out1_valid <= '0';
      ELSIF enb = '1' THEN
        Delay23_out1_valid <= CtrlIn_valid;
      END IF;
    END IF;
  END PROCESS c_12_process;


  c_13_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_out1_valid <= '0';
      ELSIF enb = '1' THEN
        Delay10_out1_valid <= Delay23_out1_valid;
      END IF;
    END IF;
  END PROCESS c_13_process;


  c_14_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_out1_valid <= '0';
      ELSIF enb = '1' THEN
        Delay3_out1_valid <= Delay10_out1_valid;
      END IF;
    END IF;
  END PROCESS c_14_process;


  CtrlOut_hStart <= Delay3_out1_hStart;

  CtrlOut_hEnd <= Delay3_out1_hEnd;

  CtrlOut_vStart <= Delay3_out1_vStart;

  CtrlOut_vEnd <= Delay3_out1_vEnd;

  CtrlOut_valid <= Delay3_out1_valid;

END rtl;

