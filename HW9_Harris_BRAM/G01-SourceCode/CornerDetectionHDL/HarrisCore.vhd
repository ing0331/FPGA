-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\CornerDetectionHDL\HarrisCore.vhd
-- Created: 2023-06-21 14:30:33
-- 
-- Generated by MATLAB 9.14 and HDL Coder 4.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: HarrisCore
-- Source Path: CornerDetectionHDL/HDL Corner Algorithm/Corner Detector/HarrisCore
-- Hierarchy Level: 2
-- 
-- Harris Core
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.HDL_Corner_Algorithm_pkg.ALL;

ENTITY HarrisCore IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        pixelInVec                        :   IN    vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
        ShiftEnb                          :   IN    std_logic;
        hStartIn                          :   IN    std_logic;
        hEndIn                            :   IN    std_logic;
        vStartIn                          :   IN    std_logic;
        vEndIn                            :   IN    std_logic;
        validIn                           :   IN    std_logic;
        cornerOut                         :   OUT   std_logic_vector(43 DOWNTO 0);  -- sfix44
        hStartOut                         :   OUT   std_logic;
        hEndOut                           :   OUT   std_logic;
        vStartOut                         :   OUT   std_logic;
        vEndOut                           :   OUT   std_logic;
        validOut                          :   OUT   std_logic
        );
END HarrisCore;


ARCHITECTURE rtl OF HarrisCore IS

  -- Component Declarations
  COMPONENT HarrisFilterA
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          AIn                             :   IN    std_logic_vector(19 DOWNTO 0);  -- sfix20
          hStart                          :   IN    std_logic;
          hEnd                            :   IN    std_logic;
          vStart                          :   IN    std_logic;
          vEnd                            :   IN    std_logic;
          valid                           :   IN    std_logic;
          filterAout                      :   OUT   std_logic_vector(19 DOWNTO 0);  -- sfix20
          hStartOut                       :   OUT   std_logic;
          hEndOut                         :   OUT   std_logic;
          vStartOut                       :   OUT   std_logic;
          vEndOut                         :   OUT   std_logic;
          validOut                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT HarrisFilterB
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          BIn                             :   IN    std_logic_vector(19 DOWNTO 0);  -- sfix20
          hStart                          :   IN    std_logic;
          hEnd                            :   IN    std_logic;
          vStart                          :   IN    std_logic;
          vEnd                            :   IN    std_logic;
          valid                           :   IN    std_logic;
          filterBout                      :   OUT   std_logic_vector(19 DOWNTO 0)  -- sfix20
          );
  END COMPONENT;

  COMPONENT HarrisFilterC
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          CIn                             :   IN    std_logic_vector(19 DOWNTO 0);  -- sfix20
          hStart                          :   IN    std_logic;
          hEnd                            :   IN    std_logic;
          vStart                          :   IN    std_logic;
          vEnd                            :   IN    std_logic;
          valid                           :   IN    std_logic;
          filterCout                      :   OUT   std_logic_vector(19 DOWNTO 0)  -- sfix20
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : HarrisFilterA
    USE ENTITY work.HarrisFilterA(rtl);

  FOR ALL : HarrisFilterB
    USE ENTITY work.HarrisFilterB(rtl);

  FOR ALL : HarrisFilterC
    USE ENTITY work.HarrisFilterC(rtl);

  -- Signals
  SIGNAL pixelInVec_1                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL tapDelay_2_reg                   : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL tapOutData_2                     : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL tapOutData_2_2                   : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL hCastA                           : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL tapOutData_2_0                   : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL hCastB                           : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL horizSub                         : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL horizReg                         : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL intdelay_reg                     : vector_of_signed10(0 TO 1);  -- sfix10 [2]
  SIGNAL pipeA                            : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL intdelay_reg_1                   : vector_of_signed10(0 TO 1);  -- sfix10 [2]
  SIGNAL pipeB                            : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL pipeC                            : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL intdelay_reg_2                   : vector_of_signed20(0 TO 1);  -- sfix20 [2]
  SIGNAL xSquared                         : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL hStartOutKernelDelay             : std_logic;
  SIGNAL hStartDly                        : std_logic;
  SIGNAL intdelay_reg_3                   : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL hStartDlyPipe                    : std_logic;
  SIGNAL hEndOutKernelDelay               : std_logic;
  SIGNAL hEndDly                          : std_logic;
  SIGNAL intdelay_reg_4                   : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL hEndDlyPipe                      : std_logic;
  SIGNAL vStartOutKernelDelay             : std_logic;
  SIGNAL vStartDly                        : std_logic;
  SIGNAL intdelay_reg_5                   : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL vStartDlyPipe                    : std_logic;
  SIGNAL vEndOutKernelDelay               : std_logic;
  SIGNAL vEndDly                          : std_logic;
  SIGNAL intdelay_reg_6                   : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL vEndDlyPipe                      : std_logic;
  SIGNAL validOutKernelDelay              : std_logic;
  SIGNAL validDly                         : std_logic;
  SIGNAL intdelay_reg_7                   : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL validDlyPipe                     : std_logic;
  SIGNAL filtAOut                         : std_logic_vector(19 DOWNTO 0);  -- ufix20
  SIGNAL hStartA                          : std_logic;
  SIGNAL hEndA                            : std_logic;
  SIGNAL vStartA                          : std_logic;
  SIGNAL vEndA                            : std_logic;
  SIGNAL validA                           : std_logic;
  SIGNAL filtAOut_signed                  : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL intdelay_reg_8                   : vector_of_signed20(0 TO 1);  -- sfix20 [2]
  SIGNAL pipeA_1                          : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL pixelInVec_2                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL pixelInVec_0                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL tapDelay_3_reg                   : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL tapOutData_3                     : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL tapOutData_3_1                   : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL vCastA                           : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL tapDelay_1_reg                   : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL tapOutData_1                     : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL tapOutData_1_1                   : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL vCastB                           : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL vertSub                          : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL vertReg                          : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL intdelay_reg_9                   : vector_of_signed10(0 TO 1);  -- sfix10 [2]
  SIGNAL pipeA_2                          : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL intdelay_reg_10                  : vector_of_signed10(0 TO 1);  -- sfix10 [2]
  SIGNAL pipeB_1                          : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL pipeC_1                          : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL intdelay_reg_11                  : vector_of_signed20(0 TO 1);  -- sfix20 [2]
  SIGNAL ySquared                         : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL filtBOut                         : std_logic_vector(19 DOWNTO 0);  -- ufix20
  SIGNAL filtBOut_signed                  : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL intdelay_reg_12                  : vector_of_signed20(0 TO 1);  -- sfix20 [2]
  SIGNAL pipeB_2                          : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL pipeC_2                          : signed(41 DOWNTO 0);  -- sfix42
  SIGNAL intdelay_reg_13                  : vector_of_signed42(0 TO 1);  -- sfix42 [2]
  SIGNAL AtimesB                          : signed(41 DOWNTO 0);  -- sfix42
  SIGNAL intdelay_reg_14                  : vector_of_signed10(0 TO 1);  -- sfix10 [2]
  SIGNAL pipeA_3                          : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL intdelay_reg_15                  : vector_of_signed10(0 TO 1);  -- sfix10 [2]
  SIGNAL pipeB_3                          : signed(9 DOWNTO 0);  -- sfix10
  SIGNAL pipeC_3                          : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL intdelay_reg_16                  : vector_of_signed20(0 TO 1);  -- sfix20 [2]
  SIGNAL xy                               : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL filtCOut                         : std_logic_vector(19 DOWNTO 0);  -- ufix20
  SIGNAL filtCOut_signed                  : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL intdelay_reg_17                  : vector_of_signed20(0 TO 1);  -- sfix20 [2]
  SIGNAL pipeA_4                          : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL intdelay_reg_18                  : vector_of_signed20(0 TO 1);  -- sfix20 [2]
  SIGNAL pipeB_4                          : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL pipeC_4                          : signed(41 DOWNTO 0);  -- sfix42
  SIGNAL intdelay_reg_19                  : vector_of_signed42(0 TO 1);  -- sfix42 [2]
  SIGNAL Csquared                         : signed(41 DOWNTO 0);  -- sfix42
  SIGNAL presub                           : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL intdelay_reg_20                  : vector_of_signed44(0 TO 3);  -- sfix44 [4]
  SIGNAL presub_1                         : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL AplusB                           : signed(20 DOWNTO 0);  -- sfix21
  SIGNAL intdelay_reg_21                  : vector_of_signed21(0 TO 1);  -- sfix21 [2]
  SIGNAL pipeA_5                          : signed(20 DOWNTO 0);  -- sfix21
  SIGNAL intdelay_reg_22                  : vector_of_signed21(0 TO 1);  -- sfix21 [2]
  SIGNAL pipeB_5                          : signed(20 DOWNTO 0);  -- sfix21
  SIGNAL pipeC_5                          : signed(41 DOWNTO 0);  -- sfix42
  SIGNAL intdelay_reg_23                  : vector_of_signed42(0 TO 1);  -- sfix42 [2]
  SIGNAL ApBsq                            : signed(41 DOWNTO 0);  -- sfix42
  SIGNAL intdelay_reg_24                  : vector_of_signed42(0 TO 1);  -- sfix42 [2]
  SIGNAL pipeA_6                          : signed(41 DOWNTO 0);  -- sfix42
  SIGNAL k                                : unsigned(15 DOWNTO 0);  -- ufix16_En20
  SIGNAL intdelay_reg_25                  : vector_of_unsigned16(0 TO 1);  -- ufix16 [2]
  SIGNAL pipeB_6                          : unsigned(15 DOWNTO 0);  -- ufix16_En20
  SIGNAL multiplier_cast                  : signed(16 DOWNTO 0);  -- sfix17_En20
  SIGNAL multiplier_mul_temp              : signed(58 DOWNTO 0);  -- sfix59_En20
  SIGNAL multiplier_cast_1                : signed(57 DOWNTO 0);  -- sfix58_En20
  SIGNAL pipeC_6                          : signed(41 DOWNTO 0);  -- sfix42
  SIGNAL intdelay_reg_26                  : vector_of_signed42(0 TO 1);  -- sfix42 [2]
  SIGNAL kApBsq                           : signed(41 DOWNTO 0);  -- sfix42
  SIGNAL premetric                        : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL metric                           : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL thresholdValue                   : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL relop_relop1                     : std_logic;
  SIGNAL metriczero                       : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL relop_relop1_1                   : std_logic;
  SIGNAL passMetric                       : std_logic;
  SIGNAL passMetricReg                    : std_logic;
  SIGNAL cornerzero                       : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL cornerConvertReg                 : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL cornerpreout                     : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL intdelay_reg_27                  : vector_of_signed44(0 TO 1);  -- sfix44 [2]
  SIGNAL cornerOut_tmp                    : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL intdelay_reg_28                  : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL intdelay_reg_29                  : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL intdelay_reg_30                  : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL intdelay_reg_31                  : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL intdelay_reg_32                  : std_logic_vector(0 TO 1);  -- ufix1 [2]

BEGIN
  u_CornerFiltANet_inst : HarrisFilterA
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              AIn => std_logic_vector(xSquared),  -- sfix20
              hStart => hStartDlyPipe,
              hEnd => hEndDlyPipe,
              vStart => vStartDlyPipe,
              vEnd => vEndDlyPipe,
              valid => validDlyPipe,
              filterAout => filtAOut,  -- sfix20
              hStartOut => hStartA,
              hEndOut => hEndA,
              vStartOut => vStartA,
              vEndOut => vEndA,
              validOut => validA
              );

  u_CornerFiltBNet_inst : HarrisFilterB
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              BIn => std_logic_vector(ySquared),  -- sfix20
              hStart => hStartDlyPipe,
              hEnd => hEndDlyPipe,
              vStart => vStartDlyPipe,
              vEnd => vEndDlyPipe,
              valid => validDlyPipe,
              filterBout => filtBOut  -- sfix20
              );

  u_CornerFiltCNet_inst : HarrisFilterC
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              CIn => std_logic_vector(xy),  -- sfix20
              hStart => hStartDlyPipe,
              hEnd => hEndDlyPipe,
              vStart => vStartDlyPipe,
              vEnd => vEndDlyPipe,
              valid => validDlyPipe,
              filterCout => filtCOut  -- sfix20
              );

  pixelInVec_1 <= unsigned(pixelInVec(1));

  tapDelay_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        tapDelay_2_reg <= (OTHERS => to_unsigned(16#00#, 8));
      ELSIF enb = '1' AND ShiftEnb = '1' THEN
        tapDelay_2_reg(0) <= tapDelay_2_reg(1);
        tapDelay_2_reg(1) <= pixelInVec_1;
      END IF;
    END IF;
  END PROCESS tapDelay_2_process;

  tapOutData_2(0 TO 1) <= tapDelay_2_reg(0 TO 1);
  tapOutData_2(2) <= pixelInVec_1;

  tapOutData_2_2 <= tapOutData_2(2);

  hCastA <= signed(resize(tapOutData_2_2, 10));

  tapOutData_2_0 <= tapOutData_2(0);

  hCastB <= signed(resize(tapOutData_2_0, 10));

  horizSub <= hCastA - hCastB;

  reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        horizReg <= to_signed(16#000#, 10);
      ELSIF enb = '1' THEN
        horizReg <= horizSub;
      END IF;
    END IF;
  END PROCESS reg_process;


  intdelay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg <= (OTHERS => to_signed(16#000#, 10));
      ELSIF enb = '1' THEN
        intdelay_reg(0) <= horizReg;
        intdelay_reg(1) <= intdelay_reg(0);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  pipeA <= intdelay_reg(1);

  intdelay_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_1 <= (OTHERS => to_signed(16#000#, 10));
      ELSIF enb = '1' THEN
        intdelay_reg_1(0) <= horizReg;
        intdelay_reg_1(1) <= intdelay_reg_1(0);
      END IF;
    END IF;
  END PROCESS intdelay_1_process;

  pipeB <= intdelay_reg_1(1);

  pipeC <= pipeA * pipeB;

  intdelay_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_2 <= (OTHERS => to_signed(16#00000#, 20));
      ELSIF enb = '1' THEN
        intdelay_reg_2(0) <= pipeC;
        intdelay_reg_2(1) <= intdelay_reg_2(0);
      END IF;
    END IF;
  END PROCESS intdelay_2_process;

  xSquared <= intdelay_reg_2(1);

  intdelay_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hStartOutKernelDelay <= '0';
      ELSIF enb = '1' AND ShiftEnb = '1' THEN
        hStartOutKernelDelay <= hStartIn;
      END IF;
    END IF;
  END PROCESS intdelay_3_process;


  hStartDly <= hStartOutKernelDelay AND ShiftEnb;

  intdelay_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_3 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_3(0) <= hStartDly;
        intdelay_reg_3(1 TO 4) <= intdelay_reg_3(0 TO 3);
      END IF;
    END IF;
  END PROCESS intdelay_4_process;

  hStartDlyPipe <= intdelay_reg_3(4);

  intdelay_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hEndOutKernelDelay <= '0';
      ELSIF enb = '1' AND ShiftEnb = '1' THEN
        hEndOutKernelDelay <= hEndIn;
      END IF;
    END IF;
  END PROCESS intdelay_5_process;


  hEndDly <= hEndOutKernelDelay AND ShiftEnb;

  intdelay_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_4 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_4(0) <= hEndDly;
        intdelay_reg_4(1 TO 4) <= intdelay_reg_4(0 TO 3);
      END IF;
    END IF;
  END PROCESS intdelay_6_process;

  hEndDlyPipe <= intdelay_reg_4(4);

  intdelay_7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        vStartOutKernelDelay <= '0';
      ELSIF enb = '1' AND ShiftEnb = '1' THEN
        vStartOutKernelDelay <= vStartIn;
      END IF;
    END IF;
  END PROCESS intdelay_7_process;


  vStartDly <= vStartOutKernelDelay AND ShiftEnb;

  intdelay_8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_5 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_5(0) <= vStartDly;
        intdelay_reg_5(1 TO 4) <= intdelay_reg_5(0 TO 3);
      END IF;
    END IF;
  END PROCESS intdelay_8_process;

  vStartDlyPipe <= intdelay_reg_5(4);

  intdelay_9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        vEndOutKernelDelay <= '0';
      ELSIF enb = '1' AND ShiftEnb = '1' THEN
        vEndOutKernelDelay <= vEndIn;
      END IF;
    END IF;
  END PROCESS intdelay_9_process;


  vEndDly <= vEndOutKernelDelay AND ShiftEnb;

  intdelay_10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_6 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_6(0) <= vEndDly;
        intdelay_reg_6(1 TO 4) <= intdelay_reg_6(0 TO 3);
      END IF;
    END IF;
  END PROCESS intdelay_10_process;

  vEndDlyPipe <= intdelay_reg_6(4);

  intdelay_11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        validOutKernelDelay <= '0';
      ELSIF enb = '1' AND ShiftEnb = '1' THEN
        validOutKernelDelay <= validIn;
      END IF;
    END IF;
  END PROCESS intdelay_11_process;


  validDly <= validOutKernelDelay AND ShiftEnb;

  intdelay_12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_7 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_7(0) <= validDly;
        intdelay_reg_7(1 TO 4) <= intdelay_reg_7(0 TO 3);
      END IF;
    END IF;
  END PROCESS intdelay_12_process;

  validDlyPipe <= intdelay_reg_7(4);

  filtAOut_signed <= signed(filtAOut);

  intdelay_13_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_8 <= (OTHERS => to_signed(16#00000#, 20));
      ELSIF enb = '1' THEN
        intdelay_reg_8(0) <= filtAOut_signed;
        intdelay_reg_8(1) <= intdelay_reg_8(0);
      END IF;
    END IF;
  END PROCESS intdelay_13_process;

  pipeA_1 <= intdelay_reg_8(1);

  pixelInVec_2 <= unsigned(pixelInVec(2));

  pixelInVec_0 <= unsigned(pixelInVec(0));

  tapDelay_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        tapDelay_3_reg <= (OTHERS => to_unsigned(16#00#, 8));
      ELSIF enb = '1' AND ShiftEnb = '1' THEN
        tapDelay_3_reg(0) <= tapDelay_3_reg(1);
        tapDelay_3_reg(1) <= pixelInVec_2;
      END IF;
    END IF;
  END PROCESS tapDelay_3_process;

  tapOutData_3(0 TO 1) <= tapDelay_3_reg(0 TO 1);
  tapOutData_3(2) <= pixelInVec_2;

  tapOutData_3_1 <= tapOutData_3(1);

  vCastA <= signed(resize(tapOutData_3_1, 10));

  tapDelay_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        tapDelay_1_reg <= (OTHERS => to_unsigned(16#00#, 8));
      ELSIF enb = '1' AND ShiftEnb = '1' THEN
        tapDelay_1_reg(0) <= tapDelay_1_reg(1);
        tapDelay_1_reg(1) <= pixelInVec_0;
      END IF;
    END IF;
  END PROCESS tapDelay_1_process;

  tapOutData_1(0 TO 1) <= tapDelay_1_reg(0 TO 1);
  tapOutData_1(2) <= pixelInVec_0;

  tapOutData_1_1 <= tapOutData_1(1);

  vCastB <= signed(resize(tapOutData_1_1, 10));

  vertSub <= vCastA - vCastB;

  reg_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        vertReg <= to_signed(16#000#, 10);
      ELSIF enb = '1' THEN
        vertReg <= vertSub;
      END IF;
    END IF;
  END PROCESS reg_1_process;


  intdelay_14_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_9 <= (OTHERS => to_signed(16#000#, 10));
      ELSIF enb = '1' THEN
        intdelay_reg_9(0) <= vertReg;
        intdelay_reg_9(1) <= intdelay_reg_9(0);
      END IF;
    END IF;
  END PROCESS intdelay_14_process;

  pipeA_2 <= intdelay_reg_9(1);

  intdelay_15_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_10 <= (OTHERS => to_signed(16#000#, 10));
      ELSIF enb = '1' THEN
        intdelay_reg_10(0) <= vertReg;
        intdelay_reg_10(1) <= intdelay_reg_10(0);
      END IF;
    END IF;
  END PROCESS intdelay_15_process;

  pipeB_1 <= intdelay_reg_10(1);

  pipeC_1 <= pipeA_2 * pipeB_1;

  intdelay_16_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_11 <= (OTHERS => to_signed(16#00000#, 20));
      ELSIF enb = '1' THEN
        intdelay_reg_11(0) <= pipeC_1;
        intdelay_reg_11(1) <= intdelay_reg_11(0);
      END IF;
    END IF;
  END PROCESS intdelay_16_process;

  ySquared <= intdelay_reg_11(1);

  filtBOut_signed <= signed(filtBOut);

  intdelay_17_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_12 <= (OTHERS => to_signed(16#00000#, 20));
      ELSIF enb = '1' THEN
        intdelay_reg_12(0) <= filtBOut_signed;
        intdelay_reg_12(1) <= intdelay_reg_12(0);
      END IF;
    END IF;
  END PROCESS intdelay_17_process;

  pipeB_2 <= intdelay_reg_12(1);

  pipeC_2 <= resize(pipeA_1 * pipeB_2, 42);

  intdelay_18_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_13 <= (OTHERS => to_signed(0, 42));
      ELSIF enb = '1' THEN
        intdelay_reg_13(0) <= pipeC_2;
        intdelay_reg_13(1) <= intdelay_reg_13(0);
      END IF;
    END IF;
  END PROCESS intdelay_18_process;

  AtimesB <= intdelay_reg_13(1);

  intdelay_19_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_14 <= (OTHERS => to_signed(16#000#, 10));
      ELSIF enb = '1' THEN
        intdelay_reg_14(0) <= horizReg;
        intdelay_reg_14(1) <= intdelay_reg_14(0);
      END IF;
    END IF;
  END PROCESS intdelay_19_process;

  pipeA_3 <= intdelay_reg_14(1);

  intdelay_20_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_15 <= (OTHERS => to_signed(16#000#, 10));
      ELSIF enb = '1' THEN
        intdelay_reg_15(0) <= vertReg;
        intdelay_reg_15(1) <= intdelay_reg_15(0);
      END IF;
    END IF;
  END PROCESS intdelay_20_process;

  pipeB_3 <= intdelay_reg_15(1);

  pipeC_3 <= pipeA_3 * pipeB_3;

  intdelay_21_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_16 <= (OTHERS => to_signed(16#00000#, 20));
      ELSIF enb = '1' THEN
        intdelay_reg_16(0) <= pipeC_3;
        intdelay_reg_16(1) <= intdelay_reg_16(0);
      END IF;
    END IF;
  END PROCESS intdelay_21_process;

  xy <= intdelay_reg_16(1);

  filtCOut_signed <= signed(filtCOut);

  intdelay_22_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_17 <= (OTHERS => to_signed(16#00000#, 20));
      ELSIF enb = '1' THEN
        intdelay_reg_17(0) <= filtCOut_signed;
        intdelay_reg_17(1) <= intdelay_reg_17(0);
      END IF;
    END IF;
  END PROCESS intdelay_22_process;

  pipeA_4 <= intdelay_reg_17(1);

  intdelay_23_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_18 <= (OTHERS => to_signed(16#00000#, 20));
      ELSIF enb = '1' THEN
        intdelay_reg_18(0) <= filtCOut_signed;
        intdelay_reg_18(1) <= intdelay_reg_18(0);
      END IF;
    END IF;
  END PROCESS intdelay_23_process;

  pipeB_4 <= intdelay_reg_18(1);

  pipeC_4 <= resize(pipeA_4 * pipeB_4, 42);

  intdelay_24_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_19 <= (OTHERS => to_signed(0, 42));
      ELSIF enb = '1' THEN
        intdelay_reg_19(0) <= pipeC_4;
        intdelay_reg_19(1) <= intdelay_reg_19(0);
      END IF;
    END IF;
  END PROCESS intdelay_24_process;

  Csquared <= intdelay_reg_19(1);

  presub <= resize(resize(AtimesB, 43) - resize(Csquared, 43), 44);

  intdelay_25_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_20 <= (OTHERS => to_signed(0, 44));
      ELSIF enb = '1' THEN
        intdelay_reg_20(0) <= presub;
        intdelay_reg_20(1 TO 3) <= intdelay_reg_20(0 TO 2);
      END IF;
    END IF;
  END PROCESS intdelay_25_process;

  presub_1 <= intdelay_reg_20(3);

  AplusB <= resize(filtAOut_signed, 21) + resize(filtBOut_signed, 21);

  intdelay_26_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_21 <= (OTHERS => to_signed(16#000000#, 21));
      ELSIF enb = '1' THEN
        intdelay_reg_21(0) <= AplusB;
        intdelay_reg_21(1) <= intdelay_reg_21(0);
      END IF;
    END IF;
  END PROCESS intdelay_26_process;

  pipeA_5 <= intdelay_reg_21(1);

  intdelay_27_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_22 <= (OTHERS => to_signed(16#000000#, 21));
      ELSIF enb = '1' THEN
        intdelay_reg_22(0) <= AplusB;
        intdelay_reg_22(1) <= intdelay_reg_22(0);
      END IF;
    END IF;
  END PROCESS intdelay_27_process;

  pipeB_5 <= intdelay_reg_22(1);

  pipeC_5 <= pipeA_5 * pipeB_5;

  intdelay_28_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_23 <= (OTHERS => to_signed(0, 42));
      ELSIF enb = '1' THEN
        intdelay_reg_23(0) <= pipeC_5;
        intdelay_reg_23(1) <= intdelay_reg_23(0);
      END IF;
    END IF;
  END PROCESS intdelay_28_process;

  ApBsq <= intdelay_reg_23(1);

  intdelay_29_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_24 <= (OTHERS => to_signed(0, 42));
      ELSIF enb = '1' THEN
        intdelay_reg_24(0) <= ApBsq;
        intdelay_reg_24(1) <= intdelay_reg_24(0);
      END IF;
    END IF;
  END PROCESS intdelay_29_process;

  pipeA_6 <= intdelay_reg_24(1);

  k <= to_unsigned(16#A3D7#, 16);

  intdelay_30_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_25 <= (OTHERS => to_unsigned(16#0000#, 16));
      ELSIF enb = '1' THEN
        intdelay_reg_25(0) <= k;
        intdelay_reg_25(1) <= intdelay_reg_25(0);
      END IF;
    END IF;
  END PROCESS intdelay_30_process;

  pipeB_6 <= intdelay_reg_25(1);

  multiplier_cast <= signed(resize(pipeB_6, 17));
  multiplier_mul_temp <= pipeA_6 * multiplier_cast;
  multiplier_cast_1 <= multiplier_mul_temp(57 DOWNTO 0);
  pipeC_6 <= resize(multiplier_cast_1(57 DOWNTO 20), 42);

  intdelay_31_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_26 <= (OTHERS => to_signed(0, 42));
      ELSIF enb = '1' THEN
        intdelay_reg_26(0) <= pipeC_6;
        intdelay_reg_26(1) <= intdelay_reg_26(0);
      END IF;
    END IF;
  END PROCESS intdelay_31_process;

  kApBsq <= intdelay_reg_26(1);

  premetric <= presub_1 - resize(kApBsq, 44);

  reg_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        metric <= to_signed(0, 44);
      ELSIF enb = '1' THEN
        metric <= premetric;
      END IF;
    END IF;
  END PROCESS reg_2_process;


  thresholdValue <= to_signed(15000, 44);

  
  relop_relop1 <= '1' WHEN metric > thresholdValue ELSE
      '0';

  metriczero <= to_signed(0, 44);

  
  relop_relop1_1 <= '1' WHEN metric > metriczero ELSE
      '0';

  passMetric <= relop_relop1 AND relop_relop1_1;

  reg_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        passMetricReg <= '0';
      ELSIF enb = '1' THEN
        passMetricReg <= passMetric;
      END IF;
    END IF;
  END PROCESS reg_3_process;


  cornerzero <= to_signed(0, 44);

  reg_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        cornerConvertReg <= to_signed(0, 44);
      ELSIF enb = '1' THEN
        cornerConvertReg <= metric;
      END IF;
    END IF;
  END PROCESS reg_4_process;


  
  cornerpreout <= cornerzero WHEN passMetricReg = '0' ELSE
      cornerConvertReg;

  intdelay_32_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_27 <= (OTHERS => to_signed(0, 44));
      ELSIF enb = '1' THEN
        intdelay_reg_27(0) <= cornerpreout;
        intdelay_reg_27(1) <= intdelay_reg_27(0);
      END IF;
    END IF;
  END PROCESS intdelay_32_process;

  cornerOut_tmp <= intdelay_reg_27(1);

  cornerOut <= std_logic_vector(cornerOut_tmp);

  intdelay_33_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_28 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_28(0) <= hStartA;
        intdelay_reg_28(1) <= intdelay_reg_28(0);
      END IF;
    END IF;
  END PROCESS intdelay_33_process;

  hStartOut <= intdelay_reg_28(1);

  intdelay_34_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_29 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_29(0) <= hEndA;
        intdelay_reg_29(1) <= intdelay_reg_29(0);
      END IF;
    END IF;
  END PROCESS intdelay_34_process;

  hEndOut <= intdelay_reg_29(1);

  intdelay_35_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_30 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_30(0) <= vStartA;
        intdelay_reg_30(1) <= intdelay_reg_30(0);
      END IF;
    END IF;
  END PROCESS intdelay_35_process;

  vStartOut <= intdelay_reg_30(1);

  intdelay_36_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_31 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_31(0) <= vEndA;
        intdelay_reg_31(1) <= intdelay_reg_31(0);
      END IF;
    END IF;
  END PROCESS intdelay_36_process;

  vEndOut <= intdelay_reg_31(1);

  intdelay_37_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_32 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_32(0) <= validA;
        intdelay_reg_32(1) <= intdelay_reg_32(0);
      END IF;
    END IF;
  END PROCESS intdelay_37_process;

  validOut <= intdelay_reg_32(1);

END rtl;

