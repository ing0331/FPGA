-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\CornerDetectionHDL\DATA_MEMORY_block2.vhd
-- Created: 2023-06-21 14:30:33
-- 
-- Generated by MATLAB 9.14 and HDL Coder 4.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: DATA_MEMORY_block2
-- Source Path: CornerDetectionHDL/HDL Corner Algorithm/Corner Detector/HarrisCore/HarrisFilterC/LineBuffer/DATA_MEMORY
-- Hierarchy Level: 5
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.HDL_Corner_Algorithm_pkg.ALL;

ENTITY DATA_MEMORY_block2 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        Unloading                         :   IN    std_logic;
        pixelIn                           :   IN    std_logic_vector(19 DOWNTO 0);  -- sfix20
        hStartIn                          :   IN    std_logic;
        hEndIn                            :   IN    std_logic;
        validIn                           :   IN    std_logic;
        popEn                             :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        dataVectorOut                     :   OUT   vector_of_std_logic_vector20(0 TO 4);  -- sfix20 [5]
        popOut                            :   OUT   std_logic;
        AllAtEnd                          :   OUT   std_logic
        );
END DATA_MEMORY_block2;


ARCHITECTURE rtl OF DATA_MEMORY_block2 IS

  -- Component Declarations
  COMPONENT PushPopCounterOne_block2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          hStartIn                        :   IN    std_logic;
          popIn                           :   IN    std_logic;
          popEnable                       :   IN    std_logic;
          hEndIn                          :   IN    std_logic;
          wrAddr                          :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
          pushOut                         :   OUT   std_logic;
          rdAddr                          :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
          popOut                          :   OUT   std_logic;
          EndofLine                       :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT PushPopCounter_block2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          hStartIn                        :   IN    std_logic;
          popIn                           :   IN    std_logic;
          popEnable                       :   IN    std_logic;
          hEndIn                          :   IN    std_logic;
          writeCountPrev                  :   IN    std_logic_vector(10 DOWNTO 0);  -- ufix11
          wrAddr                          :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
          pushOut                         :   OUT   std_logic;
          rdAddr                          :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
          EndofLine                       :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : PushPopCounterOne_block2
    USE ENTITY work.PushPopCounterOne_block2(rtl);

  FOR ALL : SimpleDualPortRAM_generic
    USE ENTITY work.SimpleDualPortRAM_generic(rtl);

  FOR ALL : PushPopCounter_block2
    USE ENTITY work.PushPopCounter_block2(rtl);

  -- Signals
  SIGNAL pixelIn_signed                   : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL intdelay_reg                     : vector_of_signed20(0 TO 3);  -- sfix20 [4]
  SIGNAL pixelColumn_0                    : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL validREG                         : std_logic;
  SIGNAL unloadPop                        : std_logic;
  SIGNAL hEndREG                          : std_logic;
  SIGNAL hEndREGT                         : std_logic;
  SIGNAL unloadPopT                       : std_logic;
  SIGNAL validPop                         : std_logic;
  SIGNAL popEn_unsigned                   : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL PopEnSL                          : std_logic;
  SIGNAL writeAddr1                       : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL pushFIFO2                        : std_logic;
  SIGNAL readAddr2                        : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL popFIFO_2                        : std_logic;
  SIGNAL EndofLine1                       : std_logic;
  SIGNAL writeAddr1_unsigned              : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL writeAddrREG1                    : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL pushOutREG1                      : std_logic;
  SIGNAL pixelColumn1                     : std_logic_vector(19 DOWNTO 0);  -- ufix20
  SIGNAL PopEnSL_1                        : std_logic;
  SIGNAL writeAddr2                       : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL pushFIFO3                        : std_logic;
  SIGNAL readAddr3                        : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL EndofLine2                       : std_logic;
  SIGNAL writeAddr2_unsigned              : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL writeAddrREG2                    : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL pushOutREG2                      : std_logic;
  SIGNAL pixelColumn2                     : std_logic_vector(19 DOWNTO 0);  -- ufix20
  SIGNAL PopEnSL_2                        : std_logic;
  SIGNAL writeAddr3                       : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL pushFIFO4                        : std_logic;
  SIGNAL readAddr4                        : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL EndofLine3                       : std_logic;
  SIGNAL writeAddr3_unsigned              : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL writeAddrREG3                    : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL pushOutREG3                      : std_logic;
  SIGNAL pixelColumn3                     : std_logic_vector(19 DOWNTO 0);  -- ufix20
  SIGNAL PopEnSL_3                        : std_logic;
  SIGNAL writeAddr4                       : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL pushFIFO5                        : std_logic;
  SIGNAL readAddr5                        : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL EndofLine4                       : std_logic;
  SIGNAL writeAddr4_unsigned              : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL writeAddrREG4                    : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL pushOutREG4                      : std_logic;
  SIGNAL pixelColumn4                     : std_logic_vector(19 DOWNTO 0);  -- ufix20
  SIGNAL dataVecInt                       : vector_of_signed20(0 TO 4);  -- sfix20 [5]

BEGIN
  u_PushPopCounterOne : PushPopCounterOne_block2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              hStartIn => hStartIn,
              popIn => validPop,
              popEnable => PopEnSL,
              hEndIn => hEndREG,
              wrAddr => writeAddr1,  -- ufix11
              pushOut => pushFIFO2,
              rdAddr => readAddr2,  -- ufix11
              popOut => popFIFO_2,
              EndofLine => EndofLine1
              );

  u_SimpleDualPortRAM_Generic1 : SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 11,
                 DataWidth => 20
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(pixelColumn_0),
              wr_addr => std_logic_vector(writeAddrREG1),
              wr_en => pushOutREG1,
              rd_addr => readAddr2,
              rd_dout => pixelColumn1
              );

  u_PushPopCounter2 : PushPopCounter_block2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              hStartIn => hStartIn,
              popIn => validPop,
              popEnable => PopEnSL_1,
              hEndIn => hEndREG,
              writeCountPrev => writeAddr1,  -- ufix11
              wrAddr => writeAddr2,  -- ufix11
              pushOut => pushFIFO3,
              rdAddr => readAddr3,  -- ufix11
              EndofLine => EndofLine2
              );

  u_SimpleDualPortRAM_Generic2 : SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 11,
                 DataWidth => 20
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => pixelColumn1,
              wr_addr => std_logic_vector(writeAddrREG2),
              wr_en => pushOutREG2,
              rd_addr => readAddr3,
              rd_dout => pixelColumn2
              );

  u_PushPopCounter3 : PushPopCounter_block2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              hStartIn => hStartIn,
              popIn => validPop,
              popEnable => PopEnSL_2,
              hEndIn => hEndREG,
              writeCountPrev => writeAddr2,  -- ufix11
              wrAddr => writeAddr3,  -- ufix11
              pushOut => pushFIFO4,
              rdAddr => readAddr4,  -- ufix11
              EndofLine => EndofLine3
              );

  u_SimpleDualPortRAM_Generic3 : SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 11,
                 DataWidth => 20
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => pixelColumn2,
              wr_addr => std_logic_vector(writeAddrREG3),
              wr_en => pushOutREG3,
              rd_addr => readAddr4,
              rd_dout => pixelColumn3
              );

  u_PushPopCounter4 : PushPopCounter_block2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              hStartIn => hStartIn,
              popIn => validPop,
              popEnable => PopEnSL_3,
              hEndIn => hEndREG,
              writeCountPrev => writeAddr3,  -- ufix11
              wrAddr => writeAddr4,  -- ufix11
              pushOut => pushFIFO5,
              rdAddr => readAddr5,  -- ufix11
              EndofLine => EndofLine4
              );

  u_SimpleDualPortRAM_Generic4 : SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 11,
                 DataWidth => 20
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => pixelColumn3,
              wr_addr => std_logic_vector(writeAddrREG4),
              wr_en => pushOutREG4,
              rd_addr => readAddr5,
              rd_dout => pixelColumn4
              );

  pixelIn_signed <= signed(pixelIn);

  intdelay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg <= (OTHERS => to_signed(16#00000#, 20));
      ELSIF enb = '1' THEN
        intdelay_reg(0) <= pixelIn_signed;
        intdelay_reg(1 TO 3) <= intdelay_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  pixelColumn_0 <= intdelay_reg(3);

  reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        validREG <= '0';
      ELSIF enb = '1' THEN
        validREG <= validIn;
      END IF;
    END IF;
  END PROCESS reg_process;


  reg_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        unloadPop <= '0';
      ELSIF enb = '1' THEN
        unloadPop <= validREG;
      END IF;
    END IF;
  END PROCESS reg_1_process;


  reg_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hEndREG <= '0';
      ELSIF enb = '1' THEN
        hEndREG <= hEndIn;
      END IF;
    END IF;
  END PROCESS reg_2_process;


  reg_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hEndREGT <= '0';
      ELSIF enb = '1' THEN
        hEndREGT <= hEndREG;
      END IF;
    END IF;
  END PROCESS reg_3_process;


  unloadPopT <= hEndREGT AND (unloadPop AND Unloading);

  validPop <= validREG OR unloadPopT;

  popEn_unsigned <= unsigned(popEn);

  PopEnSL <= popEn_unsigned(0);

  writeAddr1_unsigned <= unsigned(writeAddr1);

  reg_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        writeAddrREG1 <= to_unsigned(16#000#, 11);
      ELSIF enb = '1' THEN
        writeAddrREG1 <= writeAddr1_unsigned;
      END IF;
    END IF;
  END PROCESS reg_4_process;


  reg_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        pushOutREG1 <= '0';
      ELSIF enb = '1' THEN
        pushOutREG1 <= pushFIFO2;
      END IF;
    END IF;
  END PROCESS reg_5_process;


  PopEnSL_1 <= popEn_unsigned(1);

  writeAddr2_unsigned <= unsigned(writeAddr2);

  reg_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        writeAddrREG2 <= to_unsigned(16#000#, 11);
      ELSIF enb = '1' THEN
        writeAddrREG2 <= writeAddr2_unsigned;
      END IF;
    END IF;
  END PROCESS reg_6_process;


  reg_7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        pushOutREG2 <= '0';
      ELSIF enb = '1' THEN
        pushOutREG2 <= pushFIFO3;
      END IF;
    END IF;
  END PROCESS reg_7_process;


  PopEnSL_2 <= popEn_unsigned(1);

  writeAddr3_unsigned <= unsigned(writeAddr3);

  reg_8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        writeAddrREG3 <= to_unsigned(16#000#, 11);
      ELSIF enb = '1' THEN
        writeAddrREG3 <= writeAddr3_unsigned;
      END IF;
    END IF;
  END PROCESS reg_8_process;


  reg_9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        pushOutREG3 <= '0';
      ELSIF enb = '1' THEN
        pushOutREG3 <= pushFIFO4;
      END IF;
    END IF;
  END PROCESS reg_9_process;


  PopEnSL_3 <= popEn_unsigned(1);

  writeAddr4_unsigned <= unsigned(writeAddr4);

  reg_10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        writeAddrREG4 <= to_unsigned(16#000#, 11);
      ELSIF enb = '1' THEN
        writeAddrREG4 <= writeAddr4_unsigned;
      END IF;
    END IF;
  END PROCESS reg_10_process;


  reg_11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        pushOutREG4 <= '0';
      ELSIF enb = '1' THEN
        pushOutREG4 <= pushFIFO5;
      END IF;
    END IF;
  END PROCESS reg_11_process;


  dataVecInt(0) <= pixelColumn_0;
  dataVecInt(1) <= signed(pixelColumn1);
  dataVecInt(2) <= signed(pixelColumn2);
  dataVecInt(3) <= signed(pixelColumn3);
  dataVecInt(4) <= signed(pixelColumn4);

  outputgen: FOR k IN 0 TO 4 GENERATE
    dataVectorOut(k) <= std_logic_vector(dataVecInt(k));
  END GENERATE;

  reg_12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        popOut <= '0';
      ELSIF enb = '1' THEN
        popOut <= popFIFO_2;
      END IF;
    END IF;
  END PROCESS reg_12_process;


  AllAtEnd <= EndofLine4 AND (EndofLine3 AND (EndofLine1 AND EndofLine2));

END rtl;

