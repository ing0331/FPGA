-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\CornerDetectionHDL\Corner_Detector.vhd
-- Created: 2023-06-21 14:30:33
-- 
-- Generated by MATLAB 9.14 and HDL Coder 4.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Corner_Detector
-- Source Path: CornerDetectionHDL/HDL Corner Algorithm/Corner Detector
-- Hierarchy Level: 1
-- 
-- Corner Detector
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.HDL_Corner_Algorithm_pkg.ALL;

ENTITY Corner_Detector IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        in0                               :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        in1_hStart                        :   IN    std_logic;
        in1_hEnd                          :   IN    std_logic;
        in1_vStart                        :   IN    std_logic;
        in1_vEnd                          :   IN    std_logic;
        in1_valid                         :   IN    std_logic;
        out0                              :   OUT   std_logic_vector(43 DOWNTO 0);  -- sfix44
        out1_hStart                       :   OUT   std_logic;
        out1_hEnd                         :   OUT   std_logic;
        out1_vStart                       :   OUT   std_logic;
        out1_vEnd                         :   OUT   std_logic;
        out1_valid                        :   OUT   std_logic
        );
END Corner_Detector;


ARCHITECTURE rtl OF Corner_Detector IS

  -- Component Declarations
  COMPONENT LineBuffer
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          hStartIn                        :   IN    std_logic;
          hEndIn                          :   IN    std_logic;
          vStartIn                        :   IN    std_logic;
          vEndIn                          :   IN    std_logic;
          validIn                         :   IN    std_logic;
          dataOut                         :   OUT   vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
          hStartOut                       :   OUT   std_logic;
          hEndOut                         :   OUT   std_logic;
          vStartOut                       :   OUT   std_logic;
          vEndOut                         :   OUT   std_logic;
          validOut                        :   OUT   std_logic;
          processDataOut                  :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT HarrisCore
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          pixelInVec                      :   IN    vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
          ShiftEnb                        :   IN    std_logic;
          hStartIn                        :   IN    std_logic;
          hEndIn                          :   IN    std_logic;
          vStartIn                        :   IN    std_logic;
          vEndIn                          :   IN    std_logic;
          validIn                         :   IN    std_logic;
          cornerOut                       :   OUT   std_logic_vector(43 DOWNTO 0);  -- sfix44
          hStartOut                       :   OUT   std_logic;
          hEndOut                         :   OUT   std_logic;
          vStartOut                       :   OUT   std_logic;
          vEndOut                         :   OUT   std_logic;
          validOut                        :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : LineBuffer
    USE ENTITY work.LineBuffer(rtl);

  FOR ALL : HarrisCore
    USE ENTITY work.HarrisCore(rtl);

  -- Signals
  SIGNAL LMKDataOut                       : vector_of_std_logic_vector8(0 TO 2);  -- ufix8 [3]
  SIGNAL LMKhStartOut                     : std_logic;
  SIGNAL LMKhEndOut                       : std_logic;
  SIGNAL LMKvStartOut                     : std_logic;
  SIGNAL LMKvEndOut                       : std_logic;
  SIGNAL LMKvalidOut                      : std_logic;
  SIGNAL LMKShiftEnb                      : std_logic;
  SIGNAL coreOut                          : std_logic_vector(43 DOWNTO 0);  -- ufix44
  SIGNAL corehStartOut                    : std_logic;
  SIGNAL corehEndOut                      : std_logic;
  SIGNAL corevStartOut                    : std_logic;
  SIGNAL corevEndOut                      : std_logic;
  SIGNAL corevalidOut                     : std_logic;
  SIGNAL intdelay_reg                     : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL validOutDelay                    : std_logic;
  SIGNAL const_zero                       : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL coreOut_signed                   : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL cornerNext                       : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL Corner                           : signed(43 DOWNTO 0);  -- sfix44
  SIGNAL intdelay_reg_1                   : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL hStartOutDelay                   : std_logic;
  SIGNAL hsNext                           : std_logic;
  SIGNAL hStartOut                        : std_logic;
  SIGNAL intdelay_reg_2                   : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL hEndOutDelay                     : std_logic;
  SIGNAL heNext                           : std_logic;
  SIGNAL hEndOut                          : std_logic;
  SIGNAL intdelay_reg_3                   : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL vStartOutDelay                   : std_logic;
  SIGNAL vsNext                           : std_logic;
  SIGNAL vStartOut                        : std_logic;
  SIGNAL intdelay_reg_4                   : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL vEndOutDelay                     : std_logic;
  SIGNAL veNext                           : std_logic;
  SIGNAL vEndOut                          : std_logic;
  SIGNAL validOut                         : std_logic;

BEGIN
  u_CornerLineBuffer : LineBuffer
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => in0,  -- uint8
              hStartIn => in1_hStart,
              hEndIn => in1_hEnd,
              vStartIn => in1_vStart,
              vEndIn => in1_vEnd,
              validIn => in1_valid,
              dataOut => LMKDataOut,  -- uint8 [3]
              hStartOut => LMKhStartOut,
              hEndOut => LMKhEndOut,
              vStartOut => LMKvStartOut,
              vEndOut => LMKvEndOut,
              validOut => LMKvalidOut,
              processDataOut => LMKShiftEnb
              );

  u_CornerCoreNet_inst : HarrisCore
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              pixelInVec => LMKDataOut,  -- uint8 [3]
              ShiftEnb => LMKShiftEnb,
              hStartIn => LMKhStartOut,
              hEndIn => LMKhEndOut,
              vStartIn => LMKvStartOut,
              vEndIn => LMKvEndOut,
              validIn => LMKvalidOut,
              cornerOut => coreOut,  -- sfix44
              hStartOut => corehStartOut,
              hEndOut => corehEndOut,
              vStartOut => corevStartOut,
              vEndOut => corevEndOut,
              validOut => corevalidOut
              );

  intdelay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg(0) <= corevalidOut;
        intdelay_reg(1 TO 9) <= intdelay_reg(0 TO 8);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  validOutDelay <= intdelay_reg(9);

  const_zero <= to_signed(0, 44);

  coreOut_signed <= signed(coreOut);

  
  cornerNext <= const_zero WHEN validOutDelay = '0' ELSE
      coreOut_signed;

  reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Corner <= to_signed(0, 44);
      ELSIF enb = '1' THEN
        Corner <= cornerNext;
      END IF;
    END IF;
  END PROCESS reg_process;


  out0 <= std_logic_vector(Corner);

  intdelay_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_1 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_1(0) <= corehStartOut;
        intdelay_reg_1(1 TO 9) <= intdelay_reg_1(0 TO 8);
      END IF;
    END IF;
  END PROCESS intdelay_1_process;

  hStartOutDelay <= intdelay_reg_1(9);

  hsNext <= validOutDelay AND hStartOutDelay;

  reg_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hStartOut <= '0';
      ELSIF enb = '1' THEN
        hStartOut <= hsNext;
      END IF;
    END IF;
  END PROCESS reg_1_process;


  out1_hStart <= hStartOut;

  intdelay_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_2 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_2(0) <= corehEndOut;
        intdelay_reg_2(1 TO 9) <= intdelay_reg_2(0 TO 8);
      END IF;
    END IF;
  END PROCESS intdelay_2_process;

  hEndOutDelay <= intdelay_reg_2(9);

  heNext <= validOutDelay AND hEndOutDelay;

  reg_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hEndOut <= '0';
      ELSIF enb = '1' THEN
        hEndOut <= heNext;
      END IF;
    END IF;
  END PROCESS reg_2_process;


  out1_hEnd <= hEndOut;

  intdelay_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_3 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_3(0) <= corevStartOut;
        intdelay_reg_3(1 TO 9) <= intdelay_reg_3(0 TO 8);
      END IF;
    END IF;
  END PROCESS intdelay_3_process;

  vStartOutDelay <= intdelay_reg_3(9);

  vsNext <= validOutDelay AND vStartOutDelay;

  reg_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        vStartOut <= '0';
      ELSIF enb = '1' THEN
        vStartOut <= vsNext;
      END IF;
    END IF;
  END PROCESS reg_3_process;


  out1_vStart <= vStartOut;

  intdelay_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_4 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_4(0) <= corevEndOut;
        intdelay_reg_4(1 TO 9) <= intdelay_reg_4(0 TO 8);
      END IF;
    END IF;
  END PROCESS intdelay_4_process;

  vEndOutDelay <= intdelay_reg_4(9);

  veNext <= validOutDelay AND vEndOutDelay;

  reg_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        vEndOut <= '0';
      ELSIF enb = '1' THEN
        vEndOut <= veNext;
      END IF;
    END IF;
  END PROCESS reg_4_process;


  out1_vEnd <= vEndOut;

  reg_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        validOut <= '0';
      ELSIF enb = '1' THEN
        validOut <= validOutDelay;
      END IF;
    END IF;
  END PROCESS reg_5_process;


  out1_valid <= validOut;

END rtl;

