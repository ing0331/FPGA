-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\CornerDetectionHDL\LineInfoStore_block4.vhd
-- Created: 2023-06-21 14:30:33
-- 
-- Generated by MATLAB 9.14 and HDL Coder 4.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LineInfoStore_block4
-- Source Path: CornerDetectionHDL/HDL Corner Algorithm/Corner Detector/HarrisCore/HarrisFilterB/LineBuffer/LineInfoStore
-- Hierarchy Level: 5
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY LineInfoStore_block4 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        hStartIn                          :   IN    std_logic;
        hEndIn                            :   IN    std_logic;
        validIn                           :   IN    std_logic;
        dumpControl                       :   IN    std_logic;
        preProcess                        :   IN    std_logic;
        PrePadFlag                        :   OUT   std_logic;
        OnLineFlag                        :   OUT   std_logic;
        PostPadFlag                       :   OUT   std_logic;
        DumpingFlag                       :   OUT   std_logic;
        BlankingFlag                      :   OUT   std_logic;
        hStartOut                         :   OUT   std_logic;
        hEndOut                           :   OUT   std_logic;
        validOut                          :   OUT   std_logic
        );
END LineInfoStore_block4;


ARCHITECTURE rtl OF LineInfoStore_block4 IS

  -- Signals
  SIGNAL validTemp1                       : std_logic;
  SIGNAL validTemp2                       : std_logic;
  SIGNAL hStartFirstTap                   : std_logic;
  SIGNAL intdelay_reg                     : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL hStartFinalTap                   : std_logic;
  SIGNAL hEndFirstTap                     : std_logic;
  SIGNAL hEndSecondTap                    : std_logic;
  SIGNAL intdelay_reg_1                   : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL hEndFinalTap                     : std_logic;
  SIGNAL intdelay_reg_2                   : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL validFirstTap                    : std_logic;
  SIGNAL validGate1                       : std_logic;
  SIGNAL notPreProcess                    : std_logic;
  SIGNAL validGate2                       : std_logic;
  SIGNAL validGate3                       : std_logic;
  SIGNAL validGate4                       : std_logic;

BEGIN
  validTemp1 <= validIn OR dumpControl;

  validTemp2 <= hEndIn OR validTemp1;

  reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hStartFirstTap <= '0';
      ELSIF enb = '1' AND validTemp2 = '1' THEN
        hStartFirstTap <= hStartIn;
      END IF;
    END IF;
  END PROCESS reg_process;


  intdelay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg <= (OTHERS => '0');
      ELSIF enb = '1' AND validTemp2 = '1' THEN
        intdelay_reg(0) <= hStartFirstTap;
        intdelay_reg(1) <= intdelay_reg(0);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  hStartFinalTap <= intdelay_reg(1);

  reg_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hEndFirstTap <= '0';
      ELSIF enb = '1' AND validTemp2 = '1' THEN
        hEndFirstTap <= hEndIn;
      END IF;
    END IF;
  END PROCESS reg_1_process;


  intdelay_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hEndSecondTap <= '0';
      ELSIF enb = '1' AND validTemp2 = '1' THEN
        hEndSecondTap <= hEndFirstTap;
      END IF;
    END IF;
  END PROCESS intdelay_1_process;


  intdelay_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_1 <= (OTHERS => '0');
      ELSIF enb = '1' AND validTemp2 = '1' THEN
        intdelay_reg_1(0) <= hEndSecondTap;
        intdelay_reg_1(1 TO 2) <= intdelay_reg_1(0 TO 1);
      END IF;
    END IF;
  END PROCESS intdelay_2_process;

  hEndFinalTap <= intdelay_reg_1(2);

  intdelay_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_2 <= (OTHERS => '0');
      ELSIF enb = '1' AND validTemp2 = '1' THEN
        intdelay_reg_2(0) <= validIn;
        intdelay_reg_2(1) <= intdelay_reg_2(0);
      END IF;
    END IF;
  END PROCESS intdelay_3_process;

  validFirstTap <= intdelay_reg_2(1);

  validGate1 <= hStartFirstTap AND validFirstTap;

  notPreProcess <=  NOT preProcess;

  validGate2 <= validFirstTap AND notPreProcess;

  validGate3 <= validGate1 OR validGate2;

  validGate4 <= hStartFinalTap OR validGate3;

  PrePadFlag <= hStartFirstTap;

  OnLineFlag <= hStartFinalTap;

  PostPadFlag <= hEndSecondTap;

  DumpingFlag <= hEndFirstTap;

  BlankingFlag <= hEndFinalTap;

  hStartOut <= hStartFinalTap;

  hEndOut <= hEndSecondTap;

  validOut <= validGate4;

END rtl;

