-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\CornerDetectionHDL\HarrisFilterA.vhd
-- Created: 2023-06-21 14:30:33
-- 
-- Generated by MATLAB 9.14 and HDL Coder 4.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: HarrisFilterA
-- Source Path: CornerDetectionHDL/HDL Corner Algorithm/Corner Detector/HarrisCore/HarrisFilterA
-- Hierarchy Level: 3
-- 
-- Image Filter A
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.HDL_Corner_Algorithm_pkg.ALL;

ENTITY HarrisFilterA IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        AIn                               :   IN    std_logic_vector(19 DOWNTO 0);  -- sfix20
        hStart                            :   IN    std_logic;
        hEnd                              :   IN    std_logic;
        vStart                            :   IN    std_logic;
        vEnd                              :   IN    std_logic;
        valid                             :   IN    std_logic;
        filterAout                        :   OUT   std_logic_vector(19 DOWNTO 0);  -- sfix20
        hStartOut                         :   OUT   std_logic;
        hEndOut                           :   OUT   std_logic;
        vStartOut                         :   OUT   std_logic;
        vEndOut                           :   OUT   std_logic;
        validOut                          :   OUT   std_logic
        );
END HarrisFilterA;


ARCHITECTURE rtl OF HarrisFilterA IS

  -- Component Declarations
  COMPONENT LineBuffer_block
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(19 DOWNTO 0);  -- sfix20
          hStartIn                        :   IN    std_logic;
          hEndIn                          :   IN    std_logic;
          vStartIn                        :   IN    std_logic;
          vEndIn                          :   IN    std_logic;
          validIn                         :   IN    std_logic;
          dataOut                         :   OUT   vector_of_std_logic_vector20(0 TO 4);  -- sfix20 [5]
          hStartOut                       :   OUT   std_logic;
          hEndOut                         :   OUT   std_logic;
          vStartOut                       :   OUT   std_logic;
          vEndOut                         :   OUT   std_logic;
          validOut                        :   OUT   std_logic;
          processDataOut                  :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT FIR2DKernel
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    vector_of_std_logic_vector20(0 TO 4);  -- sfix20 [5]
          vStartIn                        :   IN    std_logic;
          vEndIn                          :   IN    std_logic;
          hStartIn                        :   IN    std_logic;
          hEndIn                          :   IN    std_logic;
          validIn                         :   IN    std_logic;
          processData                     :   IN    std_logic;
          dataOut                         :   OUT   std_logic_vector(19 DOWNTO 0);  -- sfix20
          vStartOut                       :   OUT   std_logic;
          vEndOut                         :   OUT   std_logic;
          hStartOut                       :   OUT   std_logic;
          hEndOut                         :   OUT   std_logic;
          validOut                        :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : LineBuffer_block
    USE ENTITY work.LineBuffer_block(rtl);

  FOR ALL : FIR2DKernel
    USE ENTITY work.FIR2DKernel(rtl);

  -- Signals
  SIGNAL hStartIn                         : std_logic;
  SIGNAL hEndIn                           : std_logic;
  SIGNAL vStartIn                         : std_logic;
  SIGNAL vEndIn                           : std_logic;
  SIGNAL validIn                          : std_logic;
  SIGNAL AIn_signed                       : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL dataInReg                        : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL hStartInReg                      : std_logic;
  SIGNAL hendInReg                        : std_logic;
  SIGNAL vStartInReg                      : std_logic;
  SIGNAL vendInReg                        : std_logic;
  SIGNAL validInReg                       : std_logic;
  SIGNAL LMKDataOut                       : vector_of_std_logic_vector20(0 TO 4);  -- ufix20 [5]
  SIGNAL LMKhStartOut                     : std_logic;
  SIGNAL LMKhEndOut                       : std_logic;
  SIGNAL LMKvStartOut                     : std_logic;
  SIGNAL LMKvEndOut                       : std_logic;
  SIGNAL LMKvalidOut                      : std_logic;
  SIGNAL LMKprocessOut                    : std_logic;
  SIGNAL preFilterDataOut                 : std_logic_vector(19 DOWNTO 0);  -- ufix20
  SIGNAL prehStartOut                     : std_logic;
  SIGNAL prehEndOut                       : std_logic;
  SIGNAL prevStartOut                     : std_logic;
  SIGNAL prevEndOut                       : std_logic;
  SIGNAL preValidOut                      : std_logic;
  SIGNAL zeroOut_1                        : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL preFilterDataOut_signed          : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL preDataOut                       : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL intdelay_reg                     : vector_of_signed20(0 TO 3);  -- sfix20 [4]
  SIGNAL dataOut                          : signed(19 DOWNTO 0);  -- sfix20
  SIGNAL intdelay_reg_1                   : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL intdelay_reg_2                   : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL intdelay_reg_3                   : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL intdelay_reg_4                   : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL intdelay_reg_5                   : std_logic_vector(0 TO 3);  -- ufix1 [4]

BEGIN
  u_LineBuffer : LineBuffer_block
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(dataInReg),  -- sfix20
              hStartIn => hStartInReg,
              hEndIn => hendInReg,
              vStartIn => vStartInReg,
              vEndIn => vendInReg,
              validIn => validInReg,
              dataOut => LMKDataOut,  -- sfix20 [5]
              hStartOut => LMKhStartOut,
              hEndOut => LMKhEndOut,
              vStartOut => LMKvStartOut,
              vEndOut => LMKvEndOut,
              validOut => LMKvalidOut,
              processDataOut => LMKprocessOut
              );

  u_imagekernel_inst : FIR2DKernel
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => LMKDataOut,  -- sfix20 [5]
              vStartIn => LMKhStartOut,
              vEndIn => LMKhEndOut,
              hStartIn => LMKvStartOut,
              hEndIn => LMKvEndOut,
              validIn => LMKvalidOut,
              processData => LMKprocessOut,
              dataOut => preFilterDataOut,  -- sfix20
              vStartOut => prehStartOut,
              vEndOut => prehEndOut,
              hStartOut => prevStartOut,
              hEndOut => prevEndOut,
              validOut => preValidOut
              );

  hStartIn <= hStart;

  hEndIn <= hEnd;

  vStartIn <= vStart;

  vEndIn <= vEnd;

  validIn <= valid;

  AIn_signed <= signed(AIn);

  reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        dataInReg <= to_signed(16#00000#, 20);
      ELSIF enb = '1' THEN
        dataInReg <= AIn_signed;
      END IF;
    END IF;
  END PROCESS reg_process;


  reg_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hStartInReg <= '0';
      ELSIF enb = '1' THEN
        hStartInReg <= hStartIn;
      END IF;
    END IF;
  END PROCESS reg_1_process;


  reg_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hendInReg <= '0';
      ELSIF enb = '1' THEN
        hendInReg <= hEndIn;
      END IF;
    END IF;
  END PROCESS reg_2_process;


  reg_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        vStartInReg <= '0';
      ELSIF enb = '1' THEN
        vStartInReg <= vStartIn;
      END IF;
    END IF;
  END PROCESS reg_3_process;


  reg_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        vendInReg <= '0';
      ELSIF enb = '1' THEN
        vendInReg <= vEndIn;
      END IF;
    END IF;
  END PROCESS reg_4_process;


  reg_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        validInReg <= '0';
      ELSIF enb = '1' THEN
        validInReg <= validIn;
      END IF;
    END IF;
  END PROCESS reg_5_process;


  zeroOut_1 <= to_signed(16#00000#, 20);

  preFilterDataOut_signed <= signed(preFilterDataOut);

  
  preDataOut <= zeroOut_1 WHEN preValidOut = '0' ELSE
      preFilterDataOut_signed;

  intdelay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg <= (OTHERS => to_signed(16#00000#, 20));
      ELSIF enb = '1' THEN
        intdelay_reg(0) <= preDataOut;
        intdelay_reg(1 TO 3) <= intdelay_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  dataOut <= intdelay_reg(3);

  filterAout <= std_logic_vector(dataOut);

  intdelay_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_1 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_1(0) <= prehStartOut;
        intdelay_reg_1(1 TO 3) <= intdelay_reg_1(0 TO 2);
      END IF;
    END IF;
  END PROCESS intdelay_1_process;

  hStartOut <= intdelay_reg_1(3);

  intdelay_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_2 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_2(0) <= prehEndOut;
        intdelay_reg_2(1 TO 3) <= intdelay_reg_2(0 TO 2);
      END IF;
    END IF;
  END PROCESS intdelay_2_process;

  hEndOut <= intdelay_reg_2(3);

  intdelay_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_3 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_3(0) <= prevStartOut;
        intdelay_reg_3(1 TO 3) <= intdelay_reg_3(0 TO 2);
      END IF;
    END IF;
  END PROCESS intdelay_3_process;

  vStartOut <= intdelay_reg_3(3);

  intdelay_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_4 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_4(0) <= prevEndOut;
        intdelay_reg_4(1 TO 3) <= intdelay_reg_4(0 TO 2);
      END IF;
    END IF;
  END PROCESS intdelay_4_process;

  vEndOut <= intdelay_reg_4(3);

  intdelay_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        intdelay_reg_5 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        intdelay_reg_5(0) <= preValidOut;
        intdelay_reg_5(1 TO 3) <= intdelay_reg_5(0 TO 2);
      END IF;
    END IF;
  END PROCESS intdelay_5_process;

  validOut <= intdelay_reg_5(3);

END rtl;

